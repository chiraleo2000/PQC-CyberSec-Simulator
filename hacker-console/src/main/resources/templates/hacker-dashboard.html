<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üïµÔ∏è Hacker Console - Quantum Attack Simulator</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a0a2e 50%, #0a0a0a 100%);
            color: #00ff00;
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        .header {
            background: rgba(0, 0, 0, 0.8);
            border-bottom: 2px solid #ff0040;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .header h1 {
            color: #ff0040;
            font-size: 1.5em;
            text-shadow: 0 0 10px #ff0040;
        }
        
        .gpu-status {
            background: rgba(0, 255, 0, 0.1);
            border: 1px solid #00ff00;
            padding: 8px 15px;
            border-radius: 5px;
            font-size: 0.9em;
        }
        
        .gpu-status.active { border-color: #00ff00; color: #00ff00; }
        .gpu-status.inactive { border-color: #ff6600; color: #ff6600; }
        
        .main-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            padding: 20px;
            height: calc(100vh - 80px);
        }
        
        .panel {
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #333;
            border-radius: 10px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .panel-header {
            background: linear-gradient(90deg, #1a1a2e, #16213e);
            padding: 12px 15px;
            border-bottom: 1px solid #444;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .panel-header h2 {
            font-size: 1.1em;
            color: #00ccff;
        }
        
        .panel-header .count {
            background: #ff0040;
            color: white;
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 0.9em;
        }
        
        .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }
        
        /* Intercepted Data Styles */
        .intercepted-packet {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
            border-left: 3px solid #ff6600;
            margin-bottom: 10px;
            padding: 10px;
            border-radius: 5px;
            font-size: 0.85em;
        }
        
        .intercepted-packet.rsa { border-left-color: #ff0040; }
        .intercepted-packet.mlkem { border-left-color: #00ff00; }
        
        .packet-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            color: #888;
        }
        
        .packet-cipher {
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 0.8em;
        }
        
        .packet-cipher.vulnerable { background: #ff0040; color: white; }
        .packet-cipher.safe { background: #00cc00; color: white; }
        
        .encrypted-hex {
            background: #000;
            padding: 8px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.75em;
            color: #666;
            word-break: break-all;
            margin: 8px 0;
            max-height: 60px;
            overflow: hidden;
        }
        
        .packet-actions {
            display: flex;
            gap: 10px;
            margin-top: 8px;
        }
        
        .btn {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            transition: all 0.3s;
        }
        
        .btn-attack {
            background: linear-gradient(135deg, #ff0040, #cc0033);
            color: white;
        }
        
        .btn-attack:hover { transform: scale(1.05); box-shadow: 0 0 15px #ff0040; }
        .btn-attack:disabled { background: #333; cursor: not-allowed; }
        
        .btn-harvest {
            background: linear-gradient(135deg, #ff6600, #cc5500);
            color: white;
        }
        
        .btn-harvest:hover { transform: scale(1.05); box-shadow: 0 0 15px #ff6600; }
        
        /* Decrypted Data Styles */
        .decrypted-data {
            background: rgba(255, 0, 64, 0.1);
            border: 2px solid #ff0040;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 10px;
        }
        
        .decrypted-data h3 {
            color: #ff0040;
            margin-bottom: 10px;
            font-size: 1em;
        }
        
        /* Progress Bar Styles */
        .attack-progress {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #ff6600;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
        }
        
        .attack-progress h4 {
            color: #ff6600;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .progress-bar-container {
            background: #222;
            border-radius: 10px;
            height: 24px;
            overflow: hidden;
            margin: 10px 0;
            position: relative;
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #ff6600, #ff0040);
            transition: width 0.3s ease;
            border-radius: 10px;
        }
        
        .progress-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-weight: bold;
            text-shadow: 0 0 5px black;
            font-size: 0.9em;
        }
        
        .progress-step {
            color: #00ccff;
            font-size: 0.85em;
            margin-top: 8px;
        }
        
        /* Attack Summary */
        .attack-summary {
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #444;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
        }
        
        .attack-summary h4 {
            color: #ff6600;
            margin-bottom: 10px;
        }
        
        .summary-stat {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid #333;
        }
        
        .summary-stat:last-child { border-bottom: none; }
        
        .stat-label { color: #888; }
        .stat-value { color: #00ccff; font-weight: bold; }
        .stat-value.broken { color: #ff0040; }
        .stat-value.protected { color: #00ff00; }
        
        .decrypted-field {
            display: flex;
            padding: 5px 0;
            border-bottom: 1px solid #333;
        }
        
        .decrypted-field:last-child { border-bottom: none; }
        
        .field-label {
            color: #888;
            width: 120px;
            flex-shrink: 0;
        }
        
        .field-value {
            color: #ff6666;
        }
        
        /* Protected Data Styles */
        .protected-data {
            background: rgba(0, 255, 0, 0.1);
            border: 2px solid #00ff00;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .protected-data h3 {
            color: #00ff00;
        }
        
        /* Attack Console */
        .attack-console {
            background: #000;
            padding: 10px;
            font-size: 0.8em;
            height: 200px;
            overflow-y: auto;
        }
        
        .log-entry {
            padding: 2px 0;
            border-bottom: 1px solid #111;
        }
        
        .log-entry.error { color: #ff0040; }
        .log-entry.success { color: #00ff00; }
        .log-entry.warning { color: #ffcc00; }
        .log-entry.info { color: #00ccff; }
        
        /* Live indicator */
        .live-indicator {
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }
        
        .live-dot {
            width: 8px;
            height: 8px;
            background: #ff0040;
            border-radius: 50%;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        
        /* Auto-refresh toggle */
        .auto-refresh {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .toggle {
            position: relative;
            width: 50px;
            height: 25px;
        }
        
        .toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #333;
            transition: .4s;
            border-radius: 25px;
        }
        
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 17px;
            width: 17px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        .toggle input:checked + .toggle-slider {
            background-color: #00ff00;
        }
        
        .toggle input:checked + .toggle-slider:before {
            transform: translateX(25px);
        }
        
        /* Stats bar */
        .stats-bar {
            display: flex;
            gap: 20px;
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.5);
            border-bottom: 1px solid #333;
        }
        
        .stat {
            display: flex;
            flex-direction: column;
        }
        
        .stat-value {
            font-size: 1.5em;
            font-weight: bold;
        }
        
        .stat-value.vulnerable { color: #ff0040; }
        .stat-value.safe { color: #00ff00; }
        .stat-value.total { color: #00ccff; }
        
        .stat-label {
            font-size: 0.8em;
            color: #888;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üïµÔ∏è HACKER CONSOLE - Quantum Attack Simulator</h1>
        <div style="display: flex; gap: 20px; align-items: center;">
            <div class="auto-refresh">
                <span>Live Monitor</span>
                <label class="toggle">
                    <input type="checkbox" id="autoRefresh" checked>
                    <span class="toggle-slider"></span>
                </label>
            </div>
            <div class="gpu-status" id="gpuStatus">
                üéÆ Loading GPU...
            </div>
        </div>
    </div>
    
    <div class="stats-bar">
        <div class="stat">
            <span class="stat-value total" id="totalPackets">0</span>
            <span class="stat-label">Intercepted Packets</span>
        </div>
        <div class="stat">
            <span class="stat-value vulnerable" id="vulnerableCount">0</span>
            <span class="stat-label">RSA Vulnerable</span>
        </div>
        <div class="stat">
            <span class="stat-value safe" id="safeCount">0</span>
            <span class="stat-label">PQC Protected</span>
        </div>
        <div class="stat">
            <span class="stat-value vulnerable" id="decryptedCount">0</span>
            <span class="stat-label">Decrypted</span>
        </div>
    </div>
    
    <div class="main-container">
        <!-- Left Panel: Intercepted Encrypted Traffic -->
        <div class="panel">
            <div class="panel-header">
                <h2>üì° Intercepted Encrypted Traffic</h2>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <div class="live-indicator">
                        <div class="live-dot"></div>
                        <span>LIVE</span>
                    </div>
                    <button class="btn btn-harvest" onclick="harvestNow()">üéØ Harvest Now</button>
                </div>
            </div>
            <div class="panel-content" id="interceptedPanel">
                <p style="color: #666; text-align: center; padding: 20px;">
                    Monitoring network traffic...<br>
                    Waiting for encrypted data transmissions...
                </p>
            </div>
        </div>
        
        <!-- Right Panel: Attack Results -->
        <div class="panel">
            <div class="panel-header">
                <h2>‚öõÔ∏è Quantum Attack Results</h2>
                <button class="btn btn-attack" onclick="attackAllVulnerable()">üöÄ Attack All RSA</button>
            </div>
            <div class="panel-content" id="attackResultsPanel">
                <p style="color: #666; text-align: center; padding: 20px;">
                    No attacks executed yet.<br>
                    Harvest encrypted data first, then execute quantum attacks.
                </p>
            </div>
            
            <!-- Attack Console Log -->
            <div class="panel-header" style="border-top: 1px solid #333;">
                <h2>üìú Attack Console</h2>
            </div>
            <div class="attack-console" id="attackConsole">
                <div class="log-entry info">[SYSTEM] Hacker console initialized</div>
                <div class="log-entry info">[SYSTEM] Waiting for quantum computer access...</div>
            </div>
        </div>
    </div>
    
    <script>
        // Global state
        let interceptedData = [];
        let attackResults = [];
        let autoRefreshInterval = null;
        let gpuInfo = null;
        
        /**
         * Convert algorithm enum name to display name.
         * HarvestedData entity returns 'algorithm' field with enum name (RSA_2048, ML_KEM, etc.)
         */
        function formatAlgorithmName(algo) {
            if (!algo) return 'RSA-2048';
            const upper = algo.toUpperCase();
            
            // Check for PQC algorithms first
            if (upper === 'ML_KEM' || upper === 'ML-KEM' || upper.includes('KYBER')) {
                return 'ML-KEM-768';
            }
            if (upper === 'ML_DSA' || upper === 'ML-DSA' || upper.includes('DILITHIUM')) {
                return 'ML-DSA-65';
            }
            if (upper.includes('SLH_DSA') || upper.includes('SPHINCS')) {
                return 'SLH-DSA-128';
            }
            
            // Classical algorithms
            if (upper === 'RSA_4096' || upper === 'RSA-4096') {
                return 'RSA-4096';
            }
            if (upper === 'RSA_2048' || upper === 'RSA-2048' || upper.includes('RSA')) {
                return 'RSA-2048';
            }
            if (upper.includes('AES_256') || upper.includes('AES-256')) {
                return 'AES-256';
            }
            if (upper.includes('AES')) {
                return 'AES-128';
            }
            
            return algo.replace(/_/g, '-');
        }
        
        /**
         * Get the encryption algorithm name from a packet.
         * HarvestedData uses 'algorithm' field, not 'encryptionAlgorithm'.
         */
        function getEncryptionAlgo(packet) {
            // The HarvestedData entity has 'algorithm' (enum name)
            // and 'algorithmDetails' (string with more info)
            const algo = packet.algorithm || packet.encryptionAlgorithm || 'RSA_2048';
            return formatAlgorithmName(algo);
        }
        
        /**
         * Check if a packet uses quantum-vulnerable encryption.
         */
        function isVulnerablePacket(packet) {
            // Use the entity's isQuantumResistant field if available
            if (typeof packet.quantumResistant === 'boolean') {
                return !packet.quantumResistant;
            }
            if (typeof packet.isQuantumResistant === 'boolean') {
                return !packet.isQuantumResistant;
            }
            // Fallback: check algorithm name
            const algo = getEncryptionAlgo(packet).toUpperCase();
            return algo.includes('RSA') || algo.includes('AES');
        }
        
        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            loadGpuStatus();
            loadInterceptedData();
            
            // Auto-refresh toggle
            document.getElementById('autoRefresh').addEventListener('change', (e) => {
                if (e.target.checked) {
                    startAutoRefresh();
                } else {
                    stopAutoRefresh();
                }
            });
            
            startAutoRefresh();
        });
        
        function startAutoRefresh() {
            if (autoRefreshInterval) clearInterval(autoRefreshInterval);
            autoRefreshInterval = setInterval(loadInterceptedData, 3000);
            log('Auto-refresh enabled - monitoring every 3 seconds', 'info');
        }
        
        function stopAutoRefresh() {
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
                autoRefreshInterval = null;
            }
            log('Auto-refresh disabled', 'warning');
        }
        
        async function loadGpuStatus() {
            try {
                const response = await fetch('/api/hacker/gpu');
                const data = await response.json();
                gpuInfo = data;
                
                const statusEl = document.getElementById('gpuStatus');
                statusEl.textContent = `üéÆ ${data.gpuName} (${data.vramMb}MB)`;
                statusEl.classList.add('active');
                
                log(`GPU connected: ${data.gpuName}`, 'success');
            } catch (e) {
                document.getElementById('gpuStatus').textContent = '‚ö†Ô∏è GPU Unavailable';
                document.getElementById('gpuStatus').classList.add('inactive');
                log('GPU connection failed', 'error');
            }
        }
        
        async function loadInterceptedData() {
            try {
                const response = await fetch('/api/hacker/harvested');
                const data = await response.json();
                
                if (data.length !== interceptedData.length) {
                    interceptedData = data;
                    updateInterceptedPanel();
                    updateStats();
                    
                    if (data.length > 0) {
                        log(`Intercepted ${data.length} encrypted packets`, 'warning');
                    }
                }
            } catch (e) {
                log('Failed to load intercepted data: ' + e.message, 'error');
            }
        }
        
        async function harvestNow() {
            log('Initiating network harvest...', 'info');
            
            try {
                const response = await fetch('/api/hacker/harvest/transactions', {
                    method: 'POST'
                });
                const result = await response.json();
                
                if (result.harvest && result.harvest.transactionCount > 0) {
                    log(`‚úÖ Harvested ${result.harvest.transactionCount} encrypted packets!`, 'success');
                    await loadInterceptedData();
                } else {
                    log('No new packets to harvest', 'warning');
                }
            } catch (e) {
                log('Harvest failed: ' + e.message, 'error');
            }
        }
        
        function updateInterceptedPanel() {
            const panel = document.getElementById('interceptedPanel');
            
            if (interceptedData.length === 0) {
                panel.innerHTML = `
                    <p style="color: #666; text-align: center; padding: 20px;">
                        No encrypted data intercepted yet.<br>
                        Click "Harvest Now" or wait for transmissions...
                    </p>
                `;
                return;
            }
            
            panel.innerHTML = interceptedData.map((packet, idx) => {
                const encAlgo = getEncryptionAlgo(packet);
                const isVulnerable = isVulnerablePacket(packet);
                const cipherClass = isVulnerable ? 'vulnerable' : 'safe';
                const packetClass = isVulnerable ? 'rsa' : 'mlkem';
                
                // Generate hex representation of encrypted payload
                const encryptedHex = generateEncryptedHex(packet.targetId || packet.documentId || packet.id, encAlgo);
                
                return `
                    <div class="intercepted-packet ${packetClass}">
                        <div class="packet-header">
                            <span>üì¶ Packet #${idx + 1} | ${packet.targetId || packet.documentId || packet.id || 'Unknown'}</span>
                            <span class="packet-cipher ${cipherClass}">${encAlgo}</span>
                        </div>
                        <div class="encrypted-hex">
                            üîí ${encryptedHex}
                        </div>
                        <div style="color: #666; font-size: 0.8em;">
                            Source: ${packet.sourceService || 'gov-portal:8181'} | Size: ${256 + idx * 64} bytes | 
                            ${new Date(packet.harvestedAt || packet.interceptedAt || Date.now()).toLocaleTimeString()}
                        </div>
                        <div class="packet-actions">
                            ${isVulnerable ? 
                                `<button class="btn btn-attack" onclick="attackPacket(${idx})">‚öõÔ∏è Shor's Attack</button>` :
                                `<span style="color: #00ff00;">üõ°Ô∏è Quantum-Safe</span>`
                            }
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        function generateEncryptedHex(id, algo) {
            // Generate consistent but random-looking hex based on id
            let hash = 0;
            const str = (id || '') + (algo || '');
            for (let i = 0; i < str.length; i++) {
                hash = ((hash << 5) - hash) + str.charCodeAt(i);
                hash |= 0;
            }
            
            let hex = '';
            const rand = (seed) => {
                seed = (seed * 1103515245 + 12345) & 0x7fffffff;
                return seed;
            };
            
            let seed = Math.abs(hash);
            for (let i = 0; i < 48; i++) {
                seed = rand(seed);
                hex += (seed % 256).toString(16).padStart(2, '0').toUpperCase();
                if ((i + 1) % 8 === 0 && i < 47) hex += ' ';
            }
            return hex + '...';
        }
        
        async function attackPacket(idx) {
            const packet = interceptedData[idx];
            if (!packet) return;
            
            const encAlgo = getEncryptionAlgo(packet);
            const isVuln = isVulnerablePacket(packet);
            const isPqc = encAlgo.includes('ML-KEM') || encAlgo.includes('ML-DSA');
            
            log(`‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`, 'warning');
            log(`‚öõÔ∏è QUANTUM ATTACK INITIATED`, 'warning');
            log(`‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`, 'warning');
            log(`üì¶ Target: Packet #${idx + 1} (${packet.targetId || packet.documentId || 'Unknown'})`, 'info');
            log(`üîê Algorithm: ${encAlgo}`, 'info');
            log(`üéÆ GPU: ${gpuInfo?.gpuName || 'Simulation Mode'}`, 'info');
            
            if (isPqc) {
                log(`‚ö†Ô∏è WARNING: ${encAlgo} is Post-Quantum Cryptography!`, 'warning');
                log(`üõ°Ô∏è Expected result: Attack will FAIL (quantum-resistant)`, 'info');
            } else {
                log(`üíÄ ${encAlgo} is VULNERABLE to quantum attack!`, 'error');
                log(`‚öõÔ∏è Attack method: Shor's Algorithm (period finding)`, 'info');
            }
            log(`‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`, 'info');
            
            // Show progress bar in results panel
            showProgressBar(packet, encAlgo);
            
            try {
                // Call the actual quantum attack API
                const response = await fetch('/api/hacker/quantum-attack', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ targetId: packet.targetId || packet.documentId || packet.id })
                });
                
                const result = await response.json();
                
                // Use the new detailed attack simulation
                await simulateDetailedAttack(encAlgo);
                
                // ALWAYS show results after attack completes
                showAttackResult(packet, result, isVuln);
                
                // Log final result
                log(`‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`, 'info');
                if (isVuln && !isPqc) {
                    log(`üíî ATTACK SUCCESSFUL: ${encAlgo} encryption BROKEN!`, 'success');
                    log(`üîì Private key recovered - all data decrypted`, 'success');
                } else {
                    log(`üõ°Ô∏è ATTACK FAILED: ${encAlgo} is quantum-resistant!`, 'info');
                    log(`‚úÖ Data remains PROTECTED by PQC`, 'info');
                }
                log(`‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`, 'info');
                
                updateStats();
                
            } catch (e) {
                log(`‚ùå Attack failed: ${e.message}`, 'error');
                hideProgressBar();
                showAttackError(packet, e.message);
            }
        }
        
        async function attackAllVulnerable() {
            const vulnerable = interceptedData.filter(p => isVulnerablePacket(p));
            const safe = interceptedData.filter(p => !isVulnerablePacket(p));
            
            if (interceptedData.length === 0) {
                log('‚ö†Ô∏è No packets to attack - harvest data first!', 'warning');
                return;
            }
            
            log(`‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`, 'warning');
            log(`üöÄ BULK QUANTUM ATTACK INITIATED`, 'warning');
            log(`‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`, 'warning');
            log(`üìä Total targets: ${interceptedData.length} packets`, 'info');
            log(`   ‚Ä¢ üíÄ RSA Vulnerable: ${vulnerable.length} (will be BROKEN)`, 'error');
            log(`   ‚Ä¢ üõ°Ô∏è PQC Protected: ${safe.length} (will remain SECURE)`, 'info');
            log(`üéÆ GPU: ${gpuInfo?.gpuName || 'Simulation Mode'}`, 'info');
            log(`‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`, 'info');
            log(`‚öõÔ∏è Shor's Algorithm: Quantum period finding for RSA factorization`, 'info');
            log(`üìê Mathematical basis: a^r ‚â° 1 (mod N) ‚Üí factors via gcd`, 'info');
            log(`‚è±Ô∏è Classical time: ~10^15 years | Quantum time: seconds!`, 'info');
            log(`‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`, 'info');
            
            // Show bulk progress bar
            showBulkProgressBar(interceptedData.length);
            
            try {
                const response = await fetch('/api/hacker/quantum-attack', {
                    method: 'POST'
                });
                const result = await response.json();
                
                // Use detailed attack simulation for RSA
                await simulateDetailedAttack('RSA-2048');
                
                // Show complete results
                showBulkAttackResults(result, vulnerable.length, safe.length);
                
                // Log final summary
                log(`‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`, 'info');
                log(`‚öõÔ∏è QUANTUM ATTACK COMPLETE - SUMMARY`, 'info');
                log(`‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`, 'info');
                log(`üíî RSA keys factored: ${vulnerable.length} (private keys recovered!)`, 'success');
                log(`üõ°Ô∏è PQC protected: ${safe.length} (lattice problems remain hard)`, 'info');
                log(`üìä Success rate on vulnerable targets: 100%`, 'success');
                log(`‚ö†Ô∏è LESSON: Migrate to ML-KEM/ML-DSA for quantum safety!`, 'warning');
                
                updateStats();
                
            } catch (e) {
                log(`‚ùå Bulk attack failed: ${e.message}`, 'error');
                hideProgressBar();
                showAttackError(null, e.message);
            }
        }
        
        async function simulateAttackProgress() {
            const steps = [
                { pct: 5, msg: 'Initializing quantum register (4,099 qubits)...' },
                { pct: 15, msg: 'Creating quantum superposition...' },
                { pct: 25, msg: 'Applying Hadamard gates...' },
                { pct: 40, msg: 'Loading RSA modulus into quantum memory...' },
                { pct: 55, msg: 'Executing modular exponentiation oracle...' },
                { pct: 70, msg: 'Running Quantum Fourier Transform...' },
                { pct: 85, msg: 'Measuring qubits for period finding...' },
                { pct: 95, msg: 'Computing GCD for prime factors...' },
                { pct: 100, msg: 'Attack complete!' }
            ];
            
            for (const step of steps) {
                updateProgressBar(step.pct);
                log(`[SHOR ${step.pct}%] ${step.msg}`, step.pct === 100 ? 'success' : 'info');
                await new Promise(r => setTimeout(r, 350));
            }
        }
        
        // Enhanced attack simulation with detailed technical steps
        async function simulateDetailedAttack(encAlgo) {
            const isRsa = encAlgo.includes('RSA');
            const isPqc = encAlgo.includes('ML-KEM') || encAlgo.includes('ML-DSA');
            
            let steps = [];
            if (isRsa) {
                const bits = encAlgo.includes('4096') ? 4096 : 2048;
                const qubits = 2 * bits + 3;
                steps = [
                    { pct: 3, msg: `[INIT] Allocating ${qubits} qubits for quantum register` },
                    { pct: 8, msg: `[LOAD] Loading RSA-${bits} modulus N (${bits/10} decimal digits)` },
                    { pct: 12, msg: `[MATH] Factoring goal: N = p √ó q where p,q are ${bits/2}-bit primes` },
                    { pct: 18, msg: `[RANDOM] Selected random base a = 65537, verifying gcd(a,N)=1` },
                    { pct: 25, msg: `[HADAMARD] Applying H‚äó${qubits}: |0‚ü© ‚Üí (1/‚àö2^${qubits})Œ£|x‚ü©` },
                    { pct: 32, msg: `[SUPERPOSITION] Created superposition of 2^${qubits} states on GPU` },
                    { pct: 40, msg: `[ORACLE] Computing modular exponentiation: a^x mod N in parallel` },
                    { pct: 48, msg: `[QUANTUM] Executing U_a: |x‚ü©|0‚ü© ‚Üí |x‚ü©|a^x mod N‚ü© (${Math.pow(2, Math.min(qubits, 20)).toLocaleString()} states)` },
                    { pct: 55, msg: `[QFT] Starting Quantum Fourier Transform (n¬≤=${qubits*qubits} gates)` },
                    { pct: 63, msg: `[QFT] Phase estimation: extracting period info into amplitudes` },
                    { pct: 70, msg: `[INTERFERENCE] Quantum interference amplifying periodic states` },
                    { pct: 78, msg: `[MEASURE] Measuring period register ‚Üí collapsing to eigenvalue` },
                    { pct: 83, msg: `[CLASSICAL] Continued fraction expansion: s/2^n ‚Üí convergent p/q` },
                    { pct: 88, msg: `[FACTOR] Period r found! Computing gcd(a^(r/2) ¬± 1, N)` },
                    { pct: 93, msg: `[SUCCESS] Found factors p and q! Verifying p √ó q = N ‚úì` },
                    { pct: 97, msg: `[KEYGEN] Computing private exponent: d = e^(-1) mod œÜ(N)` },
                    { pct: 100, msg: `[DECRYPT] RSA-${bits} BROKEN! Plaintext: m = c^d mod N` }
                ];
            } else if (isPqc) {
                steps = [
                    { pct: 5, msg: `[INIT] Loading ${encAlgo} lattice parameters (n=256, q=3329)` },
                    { pct: 12, msg: `[LATTICE] Constructing Module-LWE lattice structure` },
                    { pct: 20, msg: `[BKZ] Initializing BKZ-Œ≤ lattice reduction (Œ≤=20‚Üí400)` },
                    { pct: 30, msg: `[GROVER] Attempting Grover-enhanced enumeration` },
                    { pct: 40, msg: `[SVP] Searching for shortest vectors in lattice...` },
                    { pct: 50, msg: `[COMPUTE] BKZ block reduction in progress...` },
                    { pct: 60, msg: `[ANALYZE] Checking lattice gap factor Œ≥ = ||v||/Œª‚ÇÅ(L)` },
                    { pct: 70, msg: `[QUANTUM] Quantum speedup: O(‚àöN) only - NOT exponential!` },
                    { pct: 80, msg: `[FAIL] Attack complexity O(2^192) exceeds resources` },
                    { pct: 90, msg: `[SECURE] Lattice problem remains NP-hard for quantum!` },
                    { pct: 100, msg: `[PROTECTED] ${encAlgo} is QUANTUM RESISTANT - Attack FAILED!` }
                ];
            } else {
                // AES (Grover's)
                const bits = encAlgo.includes('256') ? 256 : 128;
                steps = [
                    { pct: 5, msg: `[INIT] Initializing ${bits}-qubit register for key search` },
                    { pct: 15, msg: `[SUPERPOSITION] Creating |œà‚ü© = (1/‚àö2^${bits})Œ£|k‚ü© over all keys` },
                    { pct: 25, msg: `[ORACLE] Preparing AES verification oracle O_f` },
                    { pct: 35, msg: `[GROVER] Starting Grover iterations (œÄ/4 √ó ‚àö2^${bits})` },
                    { pct: 50, msg: `[ITERATE] Amplitude amplification in progress...` },
                    { pct: 65, msg: `[QUANTUM] Target probability increasing: sin¬≤((2k+1)Œ∏)` },
                    { pct: 80, msg: `[MEASURE] Collapsing to candidate key state` },
                    { pct: 90, msg: `[VERIFY] Testing candidate against known ciphertext` },
                    { pct: 100, msg: `[COMPLETE] Grover search done (${bits}-bit ‚Üí ${bits/2}-bit effective)` }
                ];
            }
            
            for (const step of steps) {
                updateProgressBar(step.pct);
                const logType = step.msg.includes('FAIL') || step.msg.includes('PROTECTED') ? 'success' : 
                               step.msg.includes('BROKEN') || step.msg.includes('DECRYPT') ? 'error' : 'info';
                log(`[${step.pct}%] ${step.msg}`, logType);
                await new Promise(r => setTimeout(r, 250));
            }
        }
        
        function showProgressBar(packet, encAlgo) {
            const panel = document.getElementById('attackResultsPanel');
            const packetId = packet.targetId || packet.documentId || packet.id || 'Unknown';
            
            panel.innerHTML = `
                <div class="attack-progress" id="activeProgress">
                    <h4>
                        <span>‚öõÔ∏è QUANTUM ATTACK IN PROGRESS</span>
                        <span id="progressPct">0%</span>
                    </h4>
                    <div style="color: #888; font-size: 0.85em; margin-bottom: 10px;">
                        Target: ${packetId} | Algorithm: ${encAlgo}
                    </div>
                    <div class="progress-bar-container">
                        <div class="progress-bar" id="progressBar" style="width: 0%"></div>
                        <span class="progress-text" id="progressText">0%</span>
                    </div>
                    <div class="progress-step" id="progressStep">Initializing...</div>
                </div>
            ` + panel.innerHTML.replace(/<div class="attack-progress"[\s\S]*?<\/div>\s*<\/div>\s*<\/div>/g, '');
        }
        
        function showBulkProgressBar(totalCount) {
            const panel = document.getElementById('attackResultsPanel');
            
            panel.innerHTML = `
                <div class="attack-progress" id="activeProgress">
                    <h4>
                        <span>‚öõÔ∏è BULK QUANTUM ATTACK</span>
                        <span id="progressPct">0%</span>
                    </h4>
                    <div style="color: #888; font-size: 0.85em; margin-bottom: 10px;">
                        Attacking ${totalCount} intercepted packets with Shor's Algorithm
                    </div>
                    <div class="progress-bar-container">
                        <div class="progress-bar" id="progressBar" style="width: 0%"></div>
                        <span class="progress-text" id="progressText">0%</span>
                    </div>
                    <div class="progress-step" id="progressStep">Initializing quantum computer...</div>
                </div>
            `;
        }
        
        function updateProgressBar(pct) {
            const bar = document.getElementById('progressBar');
            const text = document.getElementById('progressText');
            const pctSpan = document.getElementById('progressPct');
            
            if (bar) bar.style.width = pct + '%';
            if (text) text.textContent = pct + '%';
            if (pctSpan) pctSpan.textContent = pct + '%';
        }
        
        function hideProgressBar() {
            const progress = document.getElementById('activeProgress');
            if (progress) progress.remove();
        }
        
        function showAttackResult(packet, result, isVulnerable) {
            hideProgressBar();
            const panel = document.getElementById('attackResultsPanel');
            const encAlgo = getEncryptionAlgo(packet);
            const packetId = packet.targetId || packet.documentId || packet.id || 'Unknown';
            const applicant = packet.originalSender || packet.applicant || 'Unknown';
            const isPqc = encAlgo.includes('ML-KEM') || encAlgo.includes('ML-DSA');
            
            // Get attack details from the API response
            const attackData = result.attack || result;
            const summary = result.summary || {};
            const rsaBroken = summary.rsaBroken || attackData.rsaKeysBroken || 0;
            const sigForged = attackData.rsaSignaturesForged || 0;
            const pqcProtected = summary.pqcProtected || attackData.pqcProtectedCount || 0;
            const attackResults = attackData.attackResults || [];
            
            let html = '';
            
            if (isVulnerable && !isPqc) {
                // RSA was broken!
                const keyBits = encAlgo.includes('4096') ? 4096 : 2048;
                const qubits = 2 * keyBits + 3;
                log(`üíî RSA-${keyBits} BROKEN! Private key factored!`, 'success');
                html = `
                    <div class="decrypted-data">
                        <h3>üíî DECRYPTED - RSA BROKEN!</h3>
                        <div class="decrypted-field">
                            <span class="field-label">Document ID:</span>
                            <span class="field-value">${packetId}</span>
                        </div>
                        <div class="decrypted-field">
                            <span class="field-label">Applicant:</span>
                            <span class="field-value">${applicant}</span>
                        </div>
                        <div class="decrypted-field">
                            <span class="field-label">Broken Cipher:</span>
                            <span class="field-value">${encAlgo}</span>
                        </div>
                        <div class="decrypted-field">
                            <span class="field-label">Attack Type:</span>
                            <span class="field-value">Shor's Algorithm (Quantum Period Finding)</span>
                        </div>
                        <div class="decrypted-field">
                            <span class="field-label">Qubits Used:</span>
                            <span class="field-value">~${qubits.toLocaleString()} (2n+3 for n=${keyBits})</span>
                        </div>
                        <div class="decrypted-field">
                            <span class="field-label">Key Formula:</span>
                            <span class="field-value">d = e‚Åª¬π mod œÜ(N) where œÜ(N)=(p-1)(q-1)</span>
                        </div>
                        <div class="decrypted-field">
                            <span class="field-label">Classical Time:</span>
                            <span class="field-value">~10¬π‚Åµ years (GNFS factoring)</span>
                        </div>
                        <div class="decrypted-field">
                            <span class="field-label">Quantum Time:</span>
                            <span class="field-value">~30 seconds (Shor's O(n¬≥))</span>
                        </div>
                        <p style="color: #ff6666; margin-top: 10px; font-size: 0.9em; border-top: 1px solid #ff0040; padding-top: 10px;">
                            ‚ö†Ô∏è CRYPTOGRAPHIC CATASTROPHE!<br>
                            ‚úó Private key d recovered from public key (n,e)<br>
                            ‚úó All past encrypted messages can be decrypted: m = c^d mod N<br>
                            ‚úó Digital signatures can be forged: œÉ = m^d mod N<br>
                            üíÄ RSA-${keyBits} provides ZERO security against quantum computers!
                        </p>
                    </div>
                `;
                document.getElementById('decryptedCount').textContent = 
                    parseInt(document.getElementById('decryptedCount').textContent || 0) + 1;
            } else {
                // PQC protected!
                log(`üõ°Ô∏è Attack FAILED - ${encAlgo} is quantum-resistant!`, 'info');
                html = `
                    <div class="protected-data">
                        <h3>üõ°Ô∏è PROTECTED - QUANTUM RESISTANT!</h3>
                        <p style="color: #00cc00; font-size: 1.1em;">Algorithm: <strong>${encAlgo}</strong></p>
                        <div style="text-align: left; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 5px; margin: 10px 0;">
                            <p style="color: #00ff00; margin: 5px 0;">‚úÖ Security: NIST Level 3 (192-bit quantum)</p>
                            <p style="color: #00ff00; margin: 5px 0;">‚úÖ Problem: Module-LWE (lattice-based)</p>
                            <p style="color: #00ff00; margin: 5px 0;">‚úÖ Attack cost: O(2¬π‚Åπ¬≤) operations</p>
                            <p style="color: #00ff00; margin: 5px 0;">‚úÖ Quantum speedup: None (polynomial only)</p>
                        </div>
                        <p style="color: #888; font-size: 0.9em; margin-top: 10px;">
                            üõ°Ô∏è <strong>Why Shor's Algorithm FAILS:</strong><br>
                            Shor's algorithm exploits the structure of RSA (integer factoring).<br>
                            Lattice-based crypto uses Module-LWE problem which has<br>
                            NO known efficient quantum algorithm!<br><br>
                            üìä <strong>Data remains CONFIDENTIAL and AUTHENTICATED.</strong>
                        </p>
                    </div>
                `;
            }
            
            panel.innerHTML = html + panel.innerHTML;
        }
        
        function showBulkAttackResults(result, vulnerableCount, safeCount) {
            hideProgressBar();
            const panel = document.getElementById('attackResultsPanel');
            
            // Parse API response (handles nested structure)
            const attackData = result.attack || result;
            const summary = result.summary || {};
            const rsaBroken = summary.rsaBroken || attackData.rsaKeysBroken || vulnerableCount;
            const sigForged = attackData.rsaSignaturesForged || 0;
            const pqcProtected = summary.pqcProtected || attackData.pqcProtectedCount || safeCount;
            const severity = summary.severity || attackData.severity || 'UNKNOWN';
            const overallResult = summary.result || attackData.overallResult || '';
            const attackResults = attackData.attackResults || [];
            
            log(`üíî ${rsaBroken} RSA encryptions BROKEN!`, rsaBroken > 0 ? 'success' : 'info');
            if (sigForged > 0) log(`‚úçÔ∏è ${sigForged} RSA signatures FORGED!`, 'success');
            log(`üõ°Ô∏è ${pqcProtected} packets PROTECTED by PQC`, 'info');
            
            // Build summary HTML
            let html = `
                <div class="attack-summary">
                    <h4>‚öõÔ∏è QUANTUM ATTACK COMPLETE</h4>
                    <div class="summary-stat">
                        <span class="stat-label">Total Targets:</span>
                        <span class="stat-value">${vulnerableCount + safeCount}</span>
                    </div>
                    <div class="summary-stat">
                        <span class="stat-label">üîì RSA Encryptions Broken:</span>
                        <span class="stat-value broken">${rsaBroken}</span>
                    </div>
                    <div class="summary-stat">
                        <span class="stat-label">‚úçÔ∏è RSA Signatures Forged:</span>
                        <span class="stat-value broken">${sigForged}</span>
                    </div>
                    <div class="summary-stat">
                        <span class="stat-label">üõ°Ô∏è PQC Protected:</span>
                        <span class="stat-value protected">${pqcProtected}</span>
                    </div>
                    <div class="summary-stat">
                        <span class="stat-label">Severity:</span>
                        <span class="stat-value ${severity === 'CRITICAL' ? 'broken' : 'protected'}">${severity}</span>
                    </div>
                </div>
            `;
            
            // Add individual results
            if (attackResults.length > 0) {
                attackResults.forEach(r => {
                    if (r.decrypted || r.forged) {
                        html += `
                            <div class="decrypted-data">
                                <h3>${r.forged ? '‚úçÔ∏è FORGED' : 'üíî DECRYPTED'} - ${r.documentType || 'Document'}</h3>
                                <div class="decrypted-field">
                                    <span class="field-label">Target:</span>
                                    <span class="field-value">${r.targetType || 'ENCRYPTION'}</span>
                                </div>
                                <div class="decrypted-field">
                                    <span class="field-label">Algorithm:</span>
                                    <span class="field-value">${r.algorithm}</span>
                                </div>
                                <div class="decrypted-field">
                                    <span class="field-label">Attack:</span>
                                    <span class="field-value">${r.attackType || "Shor's Algorithm"}</span>
                                </div>
                                <div class="decrypted-field">
                                    <span class="field-label">Qubits:</span>
                                    <span class="field-value">${r.qubitsUsed || '~4,099'}</span>
                                </div>
                            </div>
                        `;
                    } else {
                        html += `
                            <div class="protected-data">
                                <h3>üõ°Ô∏è PROTECTED - ${r.documentType || 'Document'}</h3>
                                <p style="margin: 5px 0;">Target: ${r.targetType || 'ENCRYPTION'} | Algo: ${r.algorithm}</p>
                                <p style="color: #00cc00; font-size: 0.9em;">
                                    ${r.details || 'Quantum-resistant algorithm - attack FAILED!'}
                                </p>
                            </div>
                        `;
                    }
                });
            } else {
                // No detailed results from API, show based on counts
                if (rsaBroken > 0) {
                    html += `
                        <div class="decrypted-data">
                            <h3>üíî ${rsaBroken} RSA DOCUMENT(S) COMPROMISED</h3>
                            <p style="color: #ff6666;">
                                Shor's Algorithm successfully factored RSA modulus!<br>
                                All RSA-encrypted documents can now be decrypted.
                            </p>
                        </div>
                    `;
                }
                if (pqcProtected > 0) {
                    html += `
                        <div class="protected-data">
                            <h3>üõ°Ô∏è ${pqcProtected} PQC DOCUMENT(S) SECURE</h3>
                            <p style="color: #00cc00;">
                                ML-KEM/ML-DSA remain quantum-resistant!<br>
                                Lattice problems are computationally infeasible.
                            </p>
                        </div>
                    `;
                }
            }
            
            panel.innerHTML = html;
            document.getElementById('decryptedCount').textContent = rsaBroken;
        }
        
        function showAttackError(packet, errorMsg) {
            const panel = document.getElementById('attackResultsPanel');
            panel.innerHTML = `
                <div class="attack-summary" style="border-color: #ff0040;">
                    <h4 style="color: #ff0040;">‚ö†Ô∏è ATTACK ERROR</h4>
                    <p style="color: #ff6666;">${errorMsg}</p>
                    <p style="color: #888; font-size: 0.9em; margin-top: 10px;">
                        Check quantum simulator connectivity and try again.
                    </p>
                </div>
            ` + panel.innerHTML;
        }
        
        // Legacy function kept for compatibility
        function showDecryptedData(packet, result) {
            showAttackResult(packet, result, isVulnerablePacket(packet));
        }
        
        // Legacy function kept for compatibility  
        function showBulkDecryptedData(result) {
            const vulnerable = interceptedData.filter(p => isVulnerablePacket(p)).length;
            const safe = interceptedData.length - vulnerable;
            showBulkAttackResults(result, vulnerable, safe);
        }
        
        function updateStats() {
            const total = interceptedData.length;
            const vulnerable = interceptedData.filter(p => isVulnerablePacket(p)).length;
            const safe = total - vulnerable;
            
            document.getElementById('totalPackets').textContent = total;
            document.getElementById('vulnerableCount').textContent = vulnerable;
            document.getElementById('safeCount').textContent = safe;
        }
        
        function log(message, type = 'info') {
            const console = document.getElementById('attackConsole');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            console.appendChild(entry);
            console.scrollTop = console.scrollHeight;
        }
    </script>
</body>
</html>
