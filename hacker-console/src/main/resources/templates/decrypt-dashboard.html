<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‚öõÔ∏è Quantum Decryption Console</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0a0a0a 0%, #2a0a3e 50%, #0a0a0a 100%);
            color: #00ff00;
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        .header {
            background: rgba(0, 0, 0, 0.9);
            border-bottom: 2px solid #9900ff;
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .header h1 {
            color: #9900ff;
            font-size: 1.2em;
            text-shadow: 0 0 10px #9900ff;
        }
        
        .gpu-status {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.85em;
            color: #00ccff;
        }
        
        .gpu-indicator {
            width: 8px;
            height: 8px;
            background: #00ff00;
            border-radius: 50%;
            animation: gpuPulse 2s infinite;
        }
        
        @keyframes gpuPulse {
            0%, 100% { box-shadow: 0 0 5px #00ff00; }
            50% { box-shadow: 0 0 15px #00ff00, 0 0 30px #00ff00; }
        }
        
        .stats-bar {
            display: flex;
            gap: 20px;
            padding: 8px 15px;
            background: rgba(0, 0, 0, 0.7);
            border-bottom: 1px solid #333;
            font-size: 0.85em;
        }
        
        .stat { display: flex; gap: 5px; }
        .stat-value { color: #9900ff; font-weight: bold; }
        .stat-value.success { color: #00ff00; }
        .stat-value.fail { color: #ff0040; }
        
        .main-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            padding: 15px;
            height: calc(100vh - 90px);
        }
        
        .panel {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #333;
            border-radius: 8px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .panel-header {
            padding: 10px 15px;
            background: linear-gradient(90deg, #1a1a3e, #2a1a4e);
            border-bottom: 1px solid #444;
            font-size: 1em;
            color: #9900ff;
        }
        
        .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }
        
        /* Queue item styles */
        .queue-item {
            background: rgba(20, 20, 40, 0.8);
            border: 1px solid #333;
            border-radius: 6px;
            margin-bottom: 8px;
            overflow: hidden;
        }
        
        .queue-item.processing {
            border-color: #9900ff;
            box-shadow: 0 0 10px rgba(153, 0, 255, 0.3);
        }
        
        .queue-item.completed { border-color: #00ff00; }
        .queue-item.failed { border-color: #ff0040; }
        
        .queue-header {
            display: flex;
            justify-content: space-between;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.5);
            font-size: 0.85em;
        }
        
        .queue-body {
            padding: 10px 12px;
        }
        
        .cipher-info {
            display: flex;
            gap: 15px;
            margin-bottom: 10px;
            font-size: 0.8em;
        }
        
        .cipher-tag {
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 0.85em;
        }
        
        .cipher-tag.rsa { background: #ff0040; color: white; }
        .cipher-tag.pqc { background: #00cc00; color: white; }
        .cipher-tag.aes { background: #ffcc00; color: black; }
        
        /* Progress bar */
        .progress-container {
            margin: 10px 0;
        }
        
        .progress-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.75em;
            color: #888;
            margin-bottom: 4px;
        }
        
        .progress-bar {
            height: 20px;
            background: #111;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #9900ff, #ff00ff);
            border-radius: 10px;
            transition: width 0.5s ease;
            position: relative;
        }
        
        .progress-fill.quantum {
            background: linear-gradient(90deg, #00ccff, #9900ff, #ff00ff);
            animation: quantumShimmer 2s infinite;
        }
        
        @keyframes quantumShimmer {
            0% { filter: hue-rotate(0deg); }
            100% { filter: hue-rotate(360deg); }
        }
        
        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: shimmer 1.5s infinite;
        }
        
        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        .progress-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.7em;
            color: white;
            text-shadow: 0 0 5px black;
            z-index: 1;
        }
        
        /* Attack steps */
        .attack-steps {
            font-size: 0.75em;
            color: #666;
            margin-top: 8px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 4px;
            max-height: 100px;
            overflow-y: auto;
        }
        
        .step { padding: 2px 0; }
        .step.active { color: #9900ff; }
        .step.done { color: #00ff00; }
        .step.done::before { content: '‚úì '; }
        
        /* Decrypted data display */
        .decrypted-result {
            margin-top: 10px;
            padding: 10px;
            background: rgba(0, 255, 0, 0.1);
            border: 1px solid #00ff00;
            border-radius: 4px;
        }
        
        .decrypted-result h4 {
            color: #00ff00;
            margin-bottom: 8px;
            font-size: 0.9em;
        }
        
        .decrypted-field {
            display: flex;
            font-size: 0.8em;
            padding: 3px 0;
            border-bottom: 1px solid #333;
        }
        
        .decrypted-field:last-child { border-bottom: none; }
        
        .field-label { color: #888; width: 100px; }
        .field-value { color: #ff6666; }
        
        /* Failed result */
        .failed-result {
            margin-top: 10px;
            padding: 10px;
            background: rgba(0, 255, 0, 0.1);
            border: 1px solid #00ff00;
            border-radius: 4px;
        }
        
        .failed-result h4 {
            color: #00ff00;
            margin-bottom: 5px;
        }
        
        /* Time estimate */
        .time-estimate {
            display: flex;
            justify-content: space-between;
            font-size: 0.75em;
            color: #666;
            margin-top: 5px;
            padding-top: 5px;
            border-top: 1px dashed #333;
        }
        
        .time-value { color: #ffcc00; }
        
        /* Controls */
        .controls {
            display: flex;
            gap: 10px;
        }
        
        .control-btn {
            background: linear-gradient(135deg, #9900ff, #6600cc);
            border: none;
            color: white;
            padding: 6px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            transition: all 0.2s;
        }
        
        .control-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px #9900ff;
        }
        
        .control-btn:disabled {
            background: #333;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        /* Console log */
        .console-log {
            background: #000;
            padding: 10px;
            font-size: 0.7em;
            max-height: 150px;
            overflow-y: auto;
        }
        
        .log-entry { padding: 2px 0; }
        .log-entry.info { color: #00ccff; }
        .log-entry.warn { color: #ffcc00; }
        .log-entry.error { color: #ff0040; }
        .log-entry.success { color: #00ff00; }
        .log-entry.quantum { color: #9900ff; }
    </style>
</head>
<body>
    <div class="header">
        <h1>‚öõÔ∏è QUANTUM DECRYPTION CONSOLE</h1>
        <div class="controls">
            <button class="control-btn" onclick="startDecryptAll()">üöÄ Decrypt All Vulnerable</button>
            <button class="control-btn" onclick="loadFromHarvest()">üì• Load Harvested Data</button>
            <button class="control-btn" onclick="clearLogs()">üóëÔ∏è Clear Logs</button>
        </div>
        <div class="gpu-status">
            <div class="gpu-indicator" id="gpuIndicator"></div>
            <span id="gpuName">Loading GPU...</span>
        </div>
    </div>
    
    <div class="stats-bar">
        <div class="stat">
            <span>Queue:</span>
            <span class="stat-value" id="queueCount">0</span>
        </div>
        <div class="stat">
            <span>Processing:</span>
            <span class="stat-value" id="processingCount">0</span>
        </div>
        <div class="stat">
            <span>Decrypted:</span>
            <span class="stat-value success" id="decryptedCount">0</span>
        </div>
        <div class="stat">
            <span>Protected (PQC):</span>
            <span class="stat-value fail" id="protectedCount">0</span>
        </div>
        <div class="stat">
            <span>GPU Memory:</span>
            <span class="stat-value" id="gpuMemory">-- MB</span>
        </div>
        <div class="stat">
            <span>Timeout:</span>
            <span class="stat-value" id="timeoutLimit">1 hour</span>
        </div>
    </div>
    
    <div class="main-container">
        <!-- Decryption Queue -->
        <div class="panel">
            <div class="panel-header">üìã Decryption Queue</div>
            <div class="panel-content" id="queuePanel">
                <div style="text-align: center; color: #666; padding: 30px;">
                    No items in queue.<br>
                    Load harvested data or wait for interception.
                </div>
            </div>
        </div>
        
        <!-- Results & Console -->
        <div class="panel">
            <div class="panel-header">üîì Decryption Results</div>
            <div class="panel-content" id="resultsPanel">
                <div style="text-align: center; color: #666; padding: 30px;">
                    No decryption results yet.<br>
                    Start quantum attack on vulnerable data.
                </div>
            </div>
            <div class="panel-header" style="border-top: 1px solid #333;">üìú Quantum Console</div>
            <div class="console-log" id="consoleLog">
                <div class="log-entry info">[SYSTEM] Quantum Decryption Console initialized</div>
                <div class="log-entry info">[SYSTEM] Connecting to cuQuantum GPU service...</div>
            </div>
            <div class="panel-header" style="border-top: 1px solid #333; background: rgba(255,100,0,0.1);">
                üî• GPU Quantum Simulation Log (Real-Time)
                <button onclick="clearLogs()" style="float: right; background: #ff3300; border: none; color: white; padding: 2px 8px; font-size: 10px; cursor: pointer; border-radius: 3px;">Clear</button>
            </div>
            <div class="console-log" id="backendLog" style="background: #0a0505; border-left: 2px solid #ff6600; max-height: 180px;">
                <div class="log-entry info">[GPU] Connecting to cuQuantum GPU Simulator on port 8184...</div>
            </div>
            
            <!-- New Quantum Simulation Detail Panel -->
            <div class="panel-header" style="border-top: 1px solid #333; background: rgba(153,0,255,0.15);">
                ‚öõÔ∏è Quantum Simulation Status
            </div>
            <div id="quantumSimPanel" style="padding: 10px; background: #0a0515; font-size: 0.75em; max-height: 150px; overflow-y: auto;">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                    <div>
                        <span style="color: #888;">GPU:</span>
                        <span id="qsGpuName" style="color: #00ff00;">Detecting...</span>
                    </div>
                    <div>
                        <span style="color: #888;">VRAM:</span>
                        <span id="qsVramUsed" style="color: #00ccff;">-- MB</span>
                    </div>
                    <div>
                        <span style="color: #888;">Qubits:</span>
                        <span id="qsQubits" style="color: #9900ff;">--</span>
                    </div>
                    <div>
                        <span style="color: #888;">Algorithm:</span>
                        <span id="qsAlgorithm" style="color: #ffcc00;">Idle</span>
                    </div>
                    <div style="grid-column: span 2;">
                        <span style="color: #888;">Current Operation:</span>
                        <span id="qsCurrentOp" style="color: #ff00ff; display: block; margin-top: 3px;">Waiting for quantum attack...</span>
                    </div>
                </div>
                <div id="qsStepProgress" style="margin-top: 8px; padding: 5px; background: rgba(0,0,0,0.5); border-radius: 4px; display: none;">
                    <div style="color: #888; margin-bottom: 3px;">Step Progress:</div>
                    <div style="height: 6px; background: #333; border-radius: 3px; overflow: hidden;">
                        <div id="qsProgressBar" style="height: 100%; width: 0%; background: linear-gradient(90deg, #9900ff, #00ff00); transition: width 0.3s;"></div>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-top: 2px; font-size: 10px;">
                        <span id="qsStepNum">Step 0/0</span>
                        <span id="qsStepPercent">0%</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Global state
        let decryptionQueue = [];
        let processingItem = null;
        let results = [];
        let gpuInfo = null;
        
        /**
         * Convert algorithm enum name to display name.
         * Input: 'RSA_2048', 'ML_KEM', 'ML_DSA', etc.
         * Output: 'RSA-2048', 'ML-KEM-768', 'ML-DSA-65', etc.
         */
        function formatAlgorithmName(algo) {
            if (!algo) return 'RSA-2048';
            const upper = algo.toUpperCase();
            
            // Check for PQC algorithms first (exact matches)
            if (upper === 'ML_KEM' || upper === 'ML-KEM' || upper.includes('KYBER')) {
                return 'ML-KEM-768';
            }
            if (upper === 'ML_DSA' || upper === 'ML-DSA' || upper.includes('DILITHIUM')) {
                return 'ML-DSA-65';
            }
            if (upper.includes('SLH_DSA') || upper.includes('SPHINCS')) {
                return 'SLH-DSA-128';
            }
            
            // Classical algorithms
            if (upper === 'RSA_4096' || upper === 'RSA-4096') {
                return 'RSA-4096';
            }
            if (upper === 'RSA_2048' || upper === 'RSA-2048' || upper.includes('RSA')) {
                return 'RSA-2048';
            }
            if (upper.includes('AES_256') || upper.includes('AES-256')) {
                return 'AES-256';
            }
            if (upper.includes('AES')) {
                return 'AES-128';
            }
            
            // Fallback: replace underscores with dashes
            return algo.replace(/_/g, '-');
        }
        
        // Decryption time estimates (realistic simulation)
        const DECRYPT_TIMES = {
            'RSA-2048': { min: 30000, max: 60000, steps: 15 },      // 30-60 seconds
            'RSA-4096': { min: 60000, max: 120000, steps: 20 },     // 1-2 minutes
            'AES-128': { min: 120000, max: 180000, steps: 25 },     // 2-3 minutes (Grover's)
            'AES-256': { min: 180000, max: 300000, steps: 30 },     // 3-5 minutes
            'ML-KEM-768': { min: 300000, max: 300000, steps: 50 },  // Will fail
            'ML-DSA-65': { min: 300000, max: 300000, steps: 50 },   // Will fail
        };
        
        const SHOR_STEPS = [
            'üîß Initializing quantum register with 4096+ qubits...',
            'üì¶ Loading RSA modulus N (2048/4096-bit) into quantum memory...',
            'üé≤ Selecting random base a < N for period finding...',
            'üåä Applying Hadamard gates H‚äón to create superposition of all states...',
            '‚öôÔ∏è Preparing ancilla qubits for modular arithmetic...',
            'üîÆ Executing modular exponentiation oracle U_a: |x‚ü©|y‚ü© ‚Üí |x‚ü©|y‚äïa^x mod N‚ü©...',
            '‚ö° Computing a^x mod N across 2^n superposed states simultaneously...',
            'üìä Applying inverse QFT (Quantum Fourier Transform) to extract period...',
            'üìè Measuring period register to collapse to eigenvalue...',
            'üßÆ Extracting period r using continued fractions algorithm...',
            'üî¢ Computing GCD(a^(r/2) - 1, N) with Euclidean algorithm...',
            'üî¢ Computing GCD(a^(r/2) + 1, N) to find factors...',
            '‚úÖ Verifying prime factors p √ó q = N...',
            'üîì Reconstructing private key d = e^(-1) mod œÜ(N)...',
            'üíÄ Decrypting ciphertext: m = c^d mod N...',
        ];
        
        const GROVER_STEPS = [
            'üîß Initializing quantum search register for key space...',
            'üåä Creating uniform superposition |œà‚ü© = 1/‚àöN Œ£|x‚ü© over all keys...',
            'üéØ Preparing oracle O_f that marks target key with phase flip...',
            'üîÑ Iteration 1: Applying oracle O_f (phase flip on target)...',
            'üìà Iteration 1: Applying diffusion D = 2|œà‚ü©‚ü®œà| - I...',
            'üîÑ Iteration 2: Oracle application O_f...',
            'üìà Iteration 2: Amplitude amplification (boosting target probability)...',
            '‚ö° Continuing Grover iterations (O(‚àöN) total required)...',
            'üéØ Approaching optimal iteration count œÄ/4 √ó ‚àöN...',
            'üìè Measuring quantum register to collapse superposition...',
            '‚úÖ Verifying candidate key against known ciphertext...',
            'üîì Key verification successful - correct key found!',
            'üíÄ Decrypting with recovered symmetric key...',
        ];
        
        const LATTICE_STEPS = [
            'üîß Initializing lattice reduction algorithm...',
            'üì¶ Loading ML-KEM/ML-DSA public parameters (module lattice)...',
            'üî® Attempting BKZ (Block Korkine-Zolotarev) reduction...',
            'üìà Increasing block size Œ≤ for better approximation...',
            '‚ö° Quantum-enhanced LLL reduction with Grover oracle...',
            'üîç Searching for short vectors in lattice...',
            '‚ùì Checking SVP (Shortest Vector Problem) solution...',
            'üíî Attack complexity O(2^n) exceeds quantum resources...',
            '‚ö†Ô∏è LATTICE PROBLEM REMAINS COMPUTATIONALLY HARD',
            'üõ°Ô∏è POST-QUANTUM CRYPTOGRAPHY PROTECTION VERIFIED',
        ];
        
        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            loadGpuInfo();
            loadFromHarvest();
            connectToQuantumService();  // Connect to Python quantum service
            
            // Initial fetch
            setTimeout(async () => {
                await checkForNewData();
                log('üîÑ Initial data sync complete', 'info');
            }, 500);
            
            // Check for new data every 2 seconds and auto-start decryption
            setInterval(async () => {
                const prevCount = decryptionQueue.length;
                await checkForNewData();
                if (decryptionQueue.length > prevCount) {
                    log(`üì• ${decryptionQueue.length - prevCount} new item(s) detected`, 'success');
                }
                autoStartDecryption();
            }, 2000);
            
            // Fetch process logs every 500ms during decryption (faster for real-time feel)
            setInterval(async () => {
                await fetchQuantumServiceLogs();
            }, 500);
        });
        
        // Python Quantum Service URL (direct connection)
        const QUANTUM_SERVICE_URL = 'http://localhost:8184';
        
        // Connect to the real Python quantum service
        async function connectToQuantumService() {
            try {
                const response = await fetch(`${QUANTUM_SERVICE_URL}/api/quantum/status`);
                if (response.ok) {
                    const data = await response.json();
                    log('‚úÖ Connected to Python cuQuantum GPU Service (port 8184)', 'success');
                    updateQuantumSimPanel(data);
                    
                    // Update GPU info from real service
                    if (data.gpu_operational) {
                        document.getElementById('qsGpuName').textContent = data.gpu_info?.name || 'GPU Active';
                        document.getElementById('qsGpuName').style.color = '#00ff00';
                    }
                } else {
                    log('‚ö†Ô∏è Quantum service returned error - using simulation', 'warn');
                }
            } catch (e) {
                log('üì° Quantum service (port 8184) not reachable - using Java simulation', 'warn');
            }
        }
        
        // Fetch logs directly from Python quantum service
        async function fetchQuantumServiceLogs() {
            try {
                // Try Python quantum service first
                const response = await fetch(`${QUANTUM_SERVICE_URL}/api/quantum/logs?limit=50`);
                if (response.ok) {
                    const data = await response.json();
                    displayQuantumServiceLogs(data);
                    return;
                }
            } catch (e) {
                // Fall back to Java service
            }
            
            // Fallback to Java hacker console logs
            await fetchProcessLogs();
        }
        
        // Display logs from Python quantum service with rich formatting
        function displayQuantumServiceLogs(data) {
            const backendLogDiv = document.getElementById('backendLog');
            
            // Update GPU status panel
            if (data.gpu_status) {
                document.getElementById('qsGpuName').textContent = data.gpu_status.name || 'Unknown';
                document.getElementById('qsVramUsed').textContent = `${data.gpu_status.memory_used_mb || 0} MB`;
                document.getElementById('qsGpuName').style.color = data.gpu_status.operational ? '#00ff00' : '#ff0040';
            }
            
            if (data.logs && data.logs.length > 0) {
                // Track displayed logs to avoid duplicates
                if (!window.displayedQuantumLogs) window.displayedQuantumLogs = new Set();
                
                const recentLogs = data.logs.slice(-30);
                recentLogs.forEach(logEntry => {
                    const logKey = `${logEntry.timestamp}-${logEntry.category}-${logEntry.message}`;
                    
                    if (!window.displayedQuantumLogs.has(logKey)) {
                        window.displayedQuantumLogs.add(logKey);
                        
                        // Determine log style based on category
                        let levelClass = 'info';
                        let categoryColor = '#ff9900';
                        
                        if (logEntry.category?.includes('SHOR')) {
                            levelClass = 'quantum';
                            categoryColor = '#9900ff';
                        } else if (logEntry.category?.includes('GROVER')) {
                            levelClass = 'quantum';
                            categoryColor = '#00ccff';
                        } else if (logEntry.category?.includes('GPU')) {
                            categoryColor = '#00ff00';
                        } else if (logEntry.category?.includes('QFT')) {
                            levelClass = 'quantum';
                            categoryColor = '#ff00ff';
                        } else if (logEntry.level === 'ERROR') {
                            levelClass = 'error';
                            categoryColor = '#ff0040';
                        } else if (logEntry.level === 'WARNING') {
                            levelClass = 'warn';
                            categoryColor = '#ffcc00';
                        }
                        
                        const timestamp = new Date(logEntry.timestamp).toLocaleTimeString();
                        const entry = document.createElement('div');
                        entry.className = `log-entry ${levelClass}`;
                        entry.innerHTML = `<span style="color:#666;">[${timestamp}]</span> <span style="color:${categoryColor};">[${logEntry.category}]</span> ${logEntry.message}`;
                        backendLogDiv.appendChild(entry);
                        
                        // Update quantum sim panel with latest step info
                        updateQuantumStepFromLog(logEntry);
                    }
                });
                
                // Auto-scroll
                backendLogDiv.scrollTop = backendLogDiv.scrollHeight;
                
                // Keep log div from getting too large
                while (backendLogDiv.children.length > 100) {
                    backendLogDiv.removeChild(backendLogDiv.firstChild);
                }
            }
        }
        
        // Update quantum simulation panel based on log entry
        function updateQuantumStepFromLog(logEntry) {
            const details = logEntry.details || {};
            
            // Update current operation
            if (logEntry.message) {
                document.getElementById('qsCurrentOp').textContent = logEntry.message;
            }
            
            // Update step progress if available
            if (details.step !== undefined && details.total_steps !== undefined) {
                document.getElementById('qsStepProgress').style.display = 'block';
                document.getElementById('qsStepNum').textContent = `Step ${details.step}/${details.total_steps}`;
                const percent = Math.round((details.step / details.total_steps) * 100);
                document.getElementById('qsStepPercent').textContent = `${percent}%`;
                document.getElementById('qsProgressBar').style.width = `${percent}%`;
            }
            
            // Update GPU memory if available
            if (details.gpu_memory_mb !== undefined) {
                document.getElementById('qsVramUsed').textContent = `${Math.round(details.gpu_memory_mb)} MB`;
            }
            
            // Update algorithm name based on category
            if (logEntry.category?.includes('SHOR')) {
                document.getElementById('qsAlgorithm').textContent = "Shor's Algorithm";
                document.getElementById('qsAlgorithm').style.color = '#9900ff';
            } else if (logEntry.category?.includes('GROVER')) {
                document.getElementById('qsAlgorithm').textContent = "Grover's Search";
                document.getElementById('qsAlgorithm').style.color = '#00ccff';
            } else if (logEntry.category?.includes('PQC') || logEntry.category?.includes('LATTICE')) {
                document.getElementById('qsAlgorithm').textContent = "Lattice Attack";
                document.getElementById('qsAlgorithm').style.color = '#ff6600';
            }
        }
        
        // Update quantum sim panel from status response
        function updateQuantumSimPanel(data) {
            if (data.gpu_info) {
                document.getElementById('qsGpuName').textContent = data.gpu_info.name || 'Unknown';
                document.getElementById('qsVramUsed').textContent = `${data.gpu_info.total_memory_mb || 0} MB total`;
            }
            document.getElementById('qsGpuName').style.color = data.gpu_operational ? '#00ff00' : '#ff0040';
        }
        
        // Auto-start decryption on new vulnerable items
        async function autoStartDecryption() {
            const vulnerable = decryptionQueue.filter(q => 
                q.status === 'queued' && 
                (q.encryption.includes('RSA') || q.encryption.includes('AES'))
            );
            
            // Only auto-start if not already processing
            if (processingItem === null && vulnerable.length > 0) {
                log(`‚öõÔ∏è Auto-starting quantum attack on ${vulnerable[0].type} (${vulnerable[0].encryption})...`, 'quantum');
                await startDecrypt(vulnerable[0].id);
            }
        }
        
        // Force sync function - callable from Selenium test
        async function forceSync() {
            log('üîÑ Force sync initiated by test automation...', 'info');
            await fetchHarvestedData();
            await fetchLiveInterceptData();
            log(`üìä Queue now has ${decryptionQueue.length} items`, 'info');
            autoStartDecryption();
            return decryptionQueue.length;
        }
        
        async function loadGpuInfo() {
            try {
                const response = await fetch('/api/hacker/gpu/status');
                const data = await response.json();
                gpuInfo = data.gpuInfo;
                
                const gpuIndicator = document.getElementById('gpuIndicator');
                if (data.gpuAvailable) {
                    document.getElementById('gpuName').textContent = 
                        `${data.gpuName} - GPU Mode Active`;
                    document.getElementById('gpuMemory').textContent = `${data.gpuMemoryMB} MB`;
                    document.getElementById('timeoutLimit').textContent = `${data.timeoutLimitHours} hour`;
                    gpuIndicator.style.background = '#00ff00';
                    log('‚úÖ GPU connected: ' + data.gpuName, 'success');
                    log(`üìä GPU Memory: ${data.gpuMemoryMB} MB | Compute: ${data.computeCapability}`, 'info');
                } else {
                    document.getElementById('gpuName').textContent = 
                        `‚ö†Ô∏è GPU UNAVAILABLE - SIMULATION MODE`;
                    document.getElementById('gpuMemory').textContent = 'N/A';
                    gpuIndicator.style.background = '#ff0040';
                    log('‚ö†Ô∏è GPU NOT AVAILABLE - Running in simulation mode!', 'error');
                }
                
                log(`‚è±Ô∏è Decryption timeout: ${data.timeoutLimitHours || 1} hour(s)`, 'info');
            } catch (e) {
                document.getElementById('gpuName').textContent = '‚ö†Ô∏è GPU Status Unknown';
                document.getElementById('gpuMemory').textContent = '--';
                log('GPU status check failed - using simulation mode', 'warn');
            }
        }
        
        // Clear logs
        async function clearLogs() {
            try {
                await fetch('/api/hacker/quantum/logs', { method: 'DELETE' });
                document.getElementById('consoleLog').innerHTML = 
                    '<div class="log-entry info">[SYSTEM] Logs cleared</div>';
                document.getElementById('backendLog').innerHTML = 
                    '<div class="log-entry info">[GPU] Logs cleared - waiting for new GPU process logs...</div>';
                window.displayedLogs = new Set();
                window.displayedBackendLogs = new Set();
                log('üóëÔ∏è Process logs cleared', 'info');
            } catch (e) {
                log('Failed to clear logs', 'error');
            }
        }
        
        // Fetch and display process logs from backend
        async function fetchProcessLogs() {
            try {
                const response = await fetch('/api/hacker/quantum/logs');
                const data = await response.json();
                
                // Update GPU memory display
                if (data.gpuStatus && data.gpuStatus.memoryUsedMB > 0) {
                    document.getElementById('gpuMemory').textContent = 
                        `${data.gpuStatus.memoryUsedMB} / ${data.gpuStatus.memoryMB || gpuInfo?.memoryMB || '?'} MB`;
                }
                
                if (data.logs && data.logs.length > 0) {
                    const backendLogDiv = document.getElementById('backendLog');
                    
                    // Get only new logs (last 20)
                    const recentLogs = data.logs.slice(-20);
                    recentLogs.forEach(logEntry => {
                        const logKey = `${logEntry.timestamp}-${logEntry.category}-${logEntry.message}`;
                        if (!window.displayedLogs) window.displayedLogs = new Set();
                        if (!window.displayedBackendLogs) window.displayedBackendLogs = new Set();
                        
                        // Add to frontend console
                        if (!window.displayedLogs.has(logKey)) {
                            window.displayedLogs.add(logKey);
                            const logType = logEntry.level === 'ERROR' ? 'error' : 
                                           logEntry.level === 'WARN' ? 'warn' : 
                                           logEntry.category.includes('SHOR') || logEntry.category.includes('GROVER') || logEntry.category.includes('PQC') ? 'quantum' : 'info';
                            log(`[${logEntry.category}] ${logEntry.message}`, logType);
                        }
                        
                        // Add to backend log panel
                        if (!window.displayedBackendLogs.has(logKey)) {
                            window.displayedBackendLogs.add(logKey);
                            const levelClass = logEntry.level === 'ERROR' ? 'error' : 
                                              logEntry.level === 'WARN' ? 'warn' : 
                                              logEntry.category.includes('GPU') ? 'quantum' : 'info';
                            const timestamp = new Date(logEntry.timestamp).toLocaleTimeString();
                            const entry = document.createElement('div');
                            entry.className = `log-entry ${levelClass}`;
                            entry.innerHTML = `<span style="color:#888;">[${timestamp}]</span> <span style="color:#ff9900;">[${logEntry.category}]</span> ${logEntry.message}`;
                            backendLogDiv.appendChild(entry);
                            backendLogDiv.scrollTop = backendLogDiv.scrollHeight;
                        }
                    });
                }
            } catch (e) {
                // Silent fail - logs may not be available
            }
        }
        
        function loadFromHarvest() {
            // Try to load from localStorage (set by harvest dashboard)
            const stored = localStorage.getItem('harvestedForDecrypt');
            if (stored) {
                try {
                    const data = JSON.parse(stored);
                    data.forEach(item => addToQueue(item));
                    localStorage.removeItem('harvestedForDecrypt');
                    log(`Loaded ${data.length} items from harvest`, 'info');
                } catch (e) {
                    log('Failed to load harvested data', 'error');
                }
            }
            
            // Also fetch from backend
            fetchHarvestedData();
        }
        
        async function fetchHarvestedData() {
            try {
                const response = await fetch('/api/hacker/harvested');
                const data = await response.json();
                
                data.forEach(item => {
                    if (!decryptionQueue.find(q => q.documentId === item.documentId)) {
                        addToQueue({
                            documentId: item.documentId || item.id,
                            type: item.documentType || item.type,
                            applicant: item.applicant,
                            encryption: item.encryptionAlgorithm || item.encryption || 'RSA-2048',
                            signature: item.signatureAlgorithm || item.signature || 'RSA-2048',
                            encryptedData: item.encryptedPayload || generateHex(512),
                            signatureData: item.signatureData || generateHex(256),
                        });
                    }
                });
            } catch (e) {
                console.log('No harvested data available');
            }
        }
        
        async function checkForNewData() {
            await fetchHarvestedData();
            await fetchLiveInterceptData();
        }
        
        async function fetchLiveInterceptData() {
            try {
                const response = await fetch('/api/hacker/intercept/live');
                const data = await response.json();
                
                if (data.newTransactions && data.newTransactions.length > 0) {
                    data.newTransactions.forEach(tx => {
                        const mapped = {
                            documentId: tx.documentId,
                            type: tx.documentType || tx.type,
                            applicant: tx.applicant,
                            // Use encryptionAlgorithm (enum name like RSA_2048, ML_KEM) from the API
                            encryption: formatAlgorithmName(tx.encryptionAlgorithm || 'RSA_2048'),
                            signature: formatAlgorithmName(tx.signatureAlgorithm || 'RSA_2048'),
                            encryptedData: generateHex(512),
                            signatureData: generateHex(256),
                        };
                        if (!decryptionQueue.find(q => q.documentId === mapped.documentId)) {
                            addToQueue(mapped);
                        }
                    });
                }
            } catch (e) {
                console.log('Live intercept fetch error:', e);
            }
        }
        
        function generateHex(length) {
            let hex = '';
            for (let i = 0; i < length; i++) {
                hex += Math.floor(Math.random() * 256).toString(16).padStart(2, '0').toUpperCase();
            }
            return hex;
        }
        
        function addToQueue(item) {
            if (decryptionQueue.find(q => q.documentId === item.documentId)) return;
            
            const queueItem = {
                id: Date.now() + Math.random(),
                documentId: item.documentId,
                type: item.type,
                applicant: item.applicant,
                encryption: item.encryption,
                signature: item.signature,
                encryptedData: item.encryptedData,
                signatureData: item.signatureData,
                status: 'queued',
                progress: 0,
                currentStep: 0,
                steps: [],
                startTime: null,
                endTime: null,
                result: null,
            };
            
            decryptionQueue.push(queueItem);
            renderQueue();
            updateStats();
            log(`Added to queue: ${item.type} (${item.encryption})`, 'info');
        }
        
        function renderQueue() {
            const container = document.getElementById('queuePanel');
            
            if (decryptionQueue.length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; color: #666; padding: 30px;">
                        No items in queue.<br>Load harvested data.
                    </div>
                `;
                return;
            }
            
            container.innerHTML = decryptionQueue.map(item => {
                const isRsa = item.encryption.includes('RSA');
                const isPqc = item.encryption.includes('ML-KEM') || item.encryption.includes('ML-DSA') || item.encryption.includes('SLH-DSA');
                const isProcessing = item.status === 'processing';
                
                const timeInfo = DECRYPT_TIMES[item.encryption] || DECRYPT_TIMES['RSA-2048'];
                const estSeconds = Math.floor((timeInfo.min + timeInfo.max) / 2000);
                
                // Calculate elapsed time for processing items
                let elapsedTime = 0;
                if (item.startTime) {
                    elapsedTime = Math.round((Date.now() - item.startTime) / 1000);
                }
                
                let statusClass = '';
                let statusIcon = '';
                if (item.status === 'processing') { statusClass = 'processing'; statusIcon = '‚ö°'; }
                else if (item.status === 'completed') { statusClass = 'completed'; statusIcon = 'üíÄ'; }
                else if (item.status === 'failed') { statusClass = 'failed'; statusIcon = 'üõ°Ô∏è'; }
                else { statusIcon = '‚è≥'; }
                
                // Determine attack type
                const attackType = isRsa ? "Shor's Algorithm" : isPqc ? "Lattice Reduction" : "Grover's Search";
                
                return `
                    <div class="queue-item ${statusClass}">
                        <div class="queue-header">
                            <span>üìÑ ${item.type} | ${item.documentId}</span>
                            <span style="color: ${item.status === 'completed' ? '#00ff00' : item.status === 'failed' ? '#ff0040' : item.status === 'processing' ? '#00ffff' : '#666'}">
                                ${statusIcon} ${item.status.toUpperCase()} ${isProcessing ? `(${elapsedTime}s)` : ''}
                            </span>
                        </div>
                        <div class="queue-body">
                            <div class="cipher-info">
                                <span>üîê Encryption:</span>
                                <span class="cipher-tag ${isPqc ? 'pqc' : (isRsa ? 'rsa' : 'aes')}">${item.encryption}</span>
                                <span>‚úçÔ∏è Signature:</span>
                                <span class="cipher-tag ${item.signature.includes('ML-DSA') || item.signature.includes('SLH-DSA') ? 'pqc' : 'rsa'}">${item.signature}</span>
                            </div>
                            
                            ${isProcessing ? `
                                <div style="margin: 8px 0; padding: 6px 10px; background: rgba(0,255,255,0.1); border-radius: 4px; font-size: 12px;">
                                    <strong>‚öõÔ∏è Attack:</strong> ${attackType} | 
                                    <strong>üéÆ GPU:</strong> ${gpuInfo?.gpuName || 'Simulation'} | 
                                    <strong>üíæ VRAM:</strong> ${gpuInfo?.gpuMemory || 'N/A'}
                                </div>
                            ` : ''}
                            
                            ${isProcessing || item.status === 'completed' || item.status === 'failed' ? `
                                <div class="progress-container">
                                    <div class="progress-label">
                                        <span style="max-width: 80%; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
                                            ${item.steps[item.currentStep] || 'Initializing...'}
                                        </span>
                                        <span><strong>${item.currentStep + 1}/${item.steps.length}</strong> | ${item.progress}%</span>
                                    </div>
                                    <div class="progress-bar">
                                        <div class="progress-fill ${isProcessing ? 'quantum' : (isPqc ? '' : 'success')}" 
                                             style="width: ${item.progress}%; ${item.status === 'failed' ? 'background: linear-gradient(90deg, #ff0040, #ff6600);' : ''}">
                                        </div>
                                        <span class="progress-text">${item.progress}%</span>
                                    </div>
                                </div>
                                <div class="attack-steps" style="max-height: 200px; overflow-y: auto;">
                                    ${item.steps.map((step, i) => `
                                        <div class="step ${i < item.currentStep ? 'done' : (i === item.currentStep ? 'active' : '')}"
                                             style="${i === item.currentStep ? 'background: rgba(0,255,255,0.2); font-weight: bold;' : ''}">
                                            ${i < item.currentStep ? '‚úÖ' : (i === item.currentStep ? '‚ñ∂Ô∏è' : '‚¨ú')} ${step}
                                        </div>
                                    `).join('')}
                                </div>
                            ` : `
                                <div class="time-estimate">
                                    <span>‚è±Ô∏è Est. decryption time:</span>
                                    <span class="time-value">${isPqc ? '‚àû (PQC Protected)' : `~${estSeconds}s`}</span>
                                </div>
                                <div style="margin-top: 5px; font-size: 11px; color: #888;">
                                    Attack method: ${attackType}
                                </div>
                            `}
                            
                            ${item.status === 'queued' ? `
                                <button class="control-btn" style="margin-top: 10px; width: 100%;"
                                        onclick="startDecrypt('${item.id}')">
                                    ‚öõÔ∏è Start Quantum Attack
                                </button>
                            ` : ''}
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        function renderResults() {
            const container = document.getElementById('resultsPanel');
            
            if (results.length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; color: #666; padding: 30px;">
                        No decryption results yet.
                    </div>
                `;
                return;
            }
            
            container.innerHTML = results.map(result => {
                if (result.success) {
                    return `
                        <div class="decrypted-result">
                            <h4>üíî DECRYPTED: ${result.type}</h4>
                            <div class="decrypted-field">
                                <span class="field-label">Doc ID:</span>
                                <span class="field-value">${result.documentId}</span>
                            </div>
                            <div class="decrypted-field">
                                <span class="field-label">Applicant:</span>
                                <span class="field-value">${result.applicant}</span>
                            </div>
                            <div class="decrypted-field">
                                <span class="field-label">Algorithm:</span>
                                <span class="field-value">${result.encryption} (BROKEN)</span>
                            </div>
                            <div class="decrypted-field">
                                <span class="field-label">Attack Time:</span>
                                <span class="field-value">${(result.attackTime / 1000).toFixed(1)}s</span>
                            </div>
                            <div class="decrypted-field">
                                <span class="field-label">Signature:</span>
                                <span class="field-value">${result.signatureForged ? 'FORGED ‚úó' : 'Verified'}</span>
                            </div>
                            <p style="color: #ff6666; font-size: 0.8em; margin-top: 8px;">
                                ‚ö†Ô∏è All personal data in this document is now EXPOSED!
                            </p>
                        </div>
                    `;
                } else {
                    return `
                        <div class="failed-result">
                            <h4>üõ°Ô∏è PROTECTED: ${result.type}</h4>
                            <div class="decrypted-field">
                                <span class="field-label">Algorithm:</span>
                                <span class="field-value" style="color: #00ff00;">${result.encryption}</span>
                            </div>
                            <div class="decrypted-field">
                                <span class="field-label">Status:</span>
                                <span class="field-value" style="color: #00ff00;">QUANTUM-RESISTANT</span>
                            </div>
                            <p style="color: #00ff00; font-size: 0.8em; margin-top: 8px;">
                                ‚úÖ Post-Quantum Cryptography successfully defended against attack!
                            </p>
                        </div>
                    `;
                }
            }).join('');
        }
        
        async function startDecrypt(itemId) {
            const item = decryptionQueue.find(q => q.id == itemId);
            if (!item || item.status !== 'queued') return;
            
            item.status = 'processing';
            item.startTime = Date.now();
            processingItem = item;
            
            const isPqc = item.encryption.includes('ML-KEM') || item.encryption.includes('ML-DSA') || item.encryption.includes('SLH-DSA');
            const isRsa = item.encryption.includes('RSA');
            const isAes = item.encryption.includes('AES');
            
            // Clear previous quantum logs for fresh display
            window.displayedQuantumLogs = new Set();
            document.getElementById('qsStepProgress').style.display = 'none';
            document.getElementById('qsCurrentOp').textContent = 'Initializing quantum attack...';
            
            // Select appropriate attack steps with more detail
            if (isRsa) {
                item.steps = [...SHOR_STEPS];
                log(`üîê Target: ${item.encryption} encryption`, 'info');
                log(`‚öõÔ∏è Attack: Shor's Algorithm (Quantum Period Finding)`, 'quantum');
                log(`üìä Qubits Required: ~${item.encryption.includes('4096') ? '8199' : '4099'} logical qubits`, 'info');
                document.getElementById('qsAlgorithm').textContent = "Shor's Algorithm";
                document.getElementById('qsQubits').textContent = item.encryption.includes('4096') ? '~8199' : '~4099';
            } else if (isAes) {
                item.steps = [...GROVER_STEPS];
                log(`üîê Target: ${item.encryption} symmetric encryption`, 'info');
                log(`‚öõÔ∏è Attack: Grover's Algorithm (Quantum Search)`, 'quantum');
                log(`üìä Speedup: Quadratic (‚àöN iterations)`, 'info');
                document.getElementById('qsAlgorithm').textContent = "Grover's Search";
                document.getElementById('qsQubits').textContent = item.encryption.includes('256') ? '~256' : '~128';
            } else {
                item.steps = [...LATTICE_STEPS];
                log(`üîê Target: ${item.encryption} (Post-Quantum Cryptography)`, 'info');
                log(`‚öõÔ∏è Attack: BKZ Lattice Reduction + Grover Enhancement`, 'quantum');
                log(`üõ°Ô∏è Expected Result: ATTACK WILL FAIL (PQC is quantum-resistant)`, 'warn');
                document.getElementById('qsAlgorithm').textContent = "Lattice Attack";
                document.getElementById('qsQubits').textContent = 'N/A (classical)';
            }
            
            const timeInfo = DECRYPT_TIMES[item.encryption] || DECRYPT_TIMES['RSA-2048'];
            const totalTime = timeInfo.min + Math.random() * (timeInfo.max - timeInfo.min);
            const stepTime = totalTime / item.steps.length;
            
            log(`‚è±Ô∏è Estimated time: ${Math.round(totalTime/1000)}s | Steps: ${item.steps.length}`, 'info');
            log(`üéÆ GPU: ${gpuInfo?.gpuName || 'Simulation Mode'}`, 'info');
            log(`----------------------------------------`, 'info');
            
            renderQueue();
            updateStats();
            
            // Trigger REAL quantum simulation on Python service (non-blocking)
            triggerRealQuantumSimulation(item, isRsa, isAes, isPqc);
            
            // Simulate decryption progress with detailed logging
            for (let i = 0; i < item.steps.length; i++) {
                // Fetch backend logs more frequently during processing
                if (i % 2 === 0) {
                    await fetchQuantumServiceLogs();
                }
                
                if (isPqc && i >= item.steps.length - 2) {
                    // PQC attack fails
                    item.currentStep = i;
                    item.progress = Math.min(95, Math.floor((i / item.steps.length) * 100));
                    renderQueue();
                    log(`[Step ${i+1}/${item.steps.length}] ${item.steps[i]}`, isPqc && i >= item.steps.length - 3 ? 'error' : 'quantum');
                    await sleep(stepTime);
                } else {
                    item.currentStep = i;
                    item.progress = Math.floor((i / item.steps.length) * 100);
                    renderQueue();
                    
                    // Show elapsed time and ETA
                    const elapsed = Math.round((Date.now() - item.startTime) / 1000);
                    const eta = Math.round(((item.steps.length - i) * stepTime) / 1000);
                    
                    log(`[Step ${i+1}/${item.steps.length}] ${item.steps[i]} | ‚è±Ô∏è ${elapsed}s elapsed, ~${eta}s remaining`, 'quantum');
                    await sleep(stepTime);
                }
            }
            
            // Final log fetch
            await fetchQuantumServiceLogs();
            
            // Complete
            item.endTime = Date.now();
            item.progress = 100;
            const totalElapsed = Math.round((item.endTime - item.startTime) / 1000);
            
            if (isPqc) {
                item.status = 'failed';
                item.result = {
                    success: false,
                    documentId: item.documentId,
                    type: item.type,
                    encryption: item.encryption,
                    message: 'Post-Quantum Cryptography resisted attack',
                };
                log(`----------------------------------------`, 'info');
                log(`üõ°Ô∏è ATTACK FAILED after ${totalElapsed}s: ${item.encryption} is quantum-resistant!`, 'success');
                log(`üìä PQC algorithms successfully defended against quantum attack`, 'success');
                document.getElementById('qsCurrentOp').textContent = 'üõ°Ô∏è PQC DEFENSE SUCCESSFUL - Attack blocked!';
            } else {
                item.status = 'completed';
                item.result = {
                    success: true,
                    documentId: item.documentId,
                    type: item.type,
                    applicant: item.applicant,
                    encryption: item.encryption,
                    attackTime: item.endTime - item.startTime,
                    signatureForged: !item.signature.includes('ML-DSA'),
                };
                log(`----------------------------------------`, 'info');
                log(`üíî DECRYPTED in ${totalElapsed}s: ${item.type} - ${item.encryption} BROKEN!`, 'error');
                log(`üìä Classical encryption vulnerable to quantum attack`, 'error');
                document.getElementById('qsCurrentOp').textContent = 'üíî RSA BROKEN - Private key recovered!';
            }
            
            results.unshift(item.result);
            processingItem = null;
            
            renderQueue();
            renderResults();
            updateStats();
            
            // Also decrypt signature if RSA
            if (isRsa && !item.signature.includes('ML-DSA')) {
                await decryptSignature(item);
            }
        }
        
        // Trigger real quantum simulation on Python service
        async function triggerRealQuantumSimulation(item, isRsa, isAes, isPqc) {
            try {
                let endpoint = '';
                let payload = {};
                
                if (isRsa) {
                    endpoint = '/api/quantum/attack/rsa';
                    payload = { 
                        key_size: item.encryption.includes('4096') ? 4096 : 2048,
                        document_id: item.documentId
                    };
                    log('üì° Sending RSA attack request to cuQuantum GPU service...', 'info');
                } else if (isAes) {
                    endpoint = '/api/quantum/grover';
                    payload = { 
                        key_bits: item.encryption.includes('256') ? 256 : 128,
                        document_id: item.documentId
                    };
                    log('üì° Sending Grover search request to cuQuantum GPU service...', 'info');
                } else if (isPqc) {
                    endpoint = '/api/quantum/attack/lattice';
                    payload = { 
                        algorithm: item.encryption,
                        security_level: 3,
                        document_id: item.documentId
                    };
                    log('üì° Sending lattice attack request to cuQuantum GPU service...', 'info');
                }
                
                if (endpoint) {
                    // Non-blocking call to trigger the real simulation
                    fetch(`${QUANTUM_SERVICE_URL}${endpoint}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    }).then(async response => {
                        if (response.ok) {
                            const result = await response.json();
                            log(`üì° GPU Simulation complete: ${result.verdict || result.algorithm || 'Done'}`, 'success');
                            console.log('Quantum service result:', result);
                        }
                    }).catch(e => {
                        console.log('Quantum service call failed (using simulation):', e);
                    });
                }
            } catch (e) {
                console.log('Could not trigger real quantum simulation:', e);
            }
        }
        
        async function decryptSignature(item) {
            log(`Starting signature forgery attack on ${item.signature}...`, 'quantum');
            await sleep(5000);
            log(`‚úó Digital signature FORGED - document integrity compromised!`, 'error');
        }
        
        async function startDecryptAll() {
            const vulnerable = decryptionQueue.filter(q => 
                q.status === 'queued' && 
                (q.encryption.includes('RSA') || q.encryption.includes('AES'))
            );
            
            if (vulnerable.length === 0) {
                log('No vulnerable items to decrypt', 'warn');
                return;
            }
            
            log(`Starting batch decryption of ${vulnerable.length} vulnerable items...`, 'info');
            
            for (const item of vulnerable) {
                await startDecrypt(item.id);
            }
            
            log('Batch decryption complete!', 'success');
        }
        
        function updateStats() {
            document.getElementById('queueCount').textContent = decryptionQueue.length;
            document.getElementById('processingCount').textContent = 
                decryptionQueue.filter(q => q.status === 'processing').length;
            document.getElementById('decryptedCount').textContent = 
                results.filter(r => r.success).length;
            document.getElementById('protectedCount').textContent = 
                results.filter(r => !r.success).length;
            
            // Calculate estimated time for remaining
            const remaining = decryptionQueue.filter(q => q.status === 'queued');
            let totalMs = 0;
            remaining.forEach(item => {
                const timeInfo = DECRYPT_TIMES[item.encryption] || DECRYPT_TIMES['RSA-2048'];
                totalMs += (timeInfo.min + timeInfo.max) / 2;
            });
            
            if (totalMs > 0) {
                const mins = Math.floor(totalMs / 60000);
                const secs = Math.floor((totalMs % 60000) / 1000);
                document.getElementById('estTime').textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
            } else {
                document.getElementById('estTime').textContent = '--:--';
            }
        }
        
        function log(message, type = 'info') {
            const container = document.getElementById('consoleLog');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            container.appendChild(entry);
            container.scrollTop = container.scrollHeight;
        }
        
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
    </script>
</body>
</html>
